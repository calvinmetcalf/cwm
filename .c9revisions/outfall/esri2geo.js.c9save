{"ts":1350657142954,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function toGeoJSON(data,cb){\r\n    var outPut = { \"type\": \"FeatureCollection\",\r\n  \"features\": []};\r\n    var fl = data.features.length;\r\n    var i = 0;\r\n    while(fl>i){\r\n     var ft = data.features[i];\r\n/* as only ESRI based products care if all the features are the same type of geometry, check for geometry type at a feature level*/\r\n     var outFT = {\r\n            \"type\": \"Feature\",\r\n            \"properties\":prop(ft.attributes)\r\n        };\r\n        if(ft.attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n        if(ft.geometry.x){\r\n//check if it's a point\r\n          outFT.geometry=point(ft.geometry);\r\n        }else if(ft.geometry.points){\r\n//check if it is a multipoint\r\n            outFT.geometry=points(ft.geometry);\r\n            }else if(ft.geometry.paths){\r\n//check if a line (or \"ARC\" in ESRI terms)\r\n         outFT.geometry=line(ft.geometry);\r\n        }else if(ft.geometry.rings){\r\n//check if a poly.\r\n           outFT.geometry=poly(ft.geometry);  \r\n        }\r\n        \r\n     outPut.features.push(outFT);\r\n     i++;\r\n    }\r\nfunction point(geometry){\r\n//this one is easy\r\n    return {\"type\": \"Point\",\"coordinates\": [geometry.x,geometry.y]};    \r\n}\r\nfunction points(geometry){\r\n//checks if the multipoint only has one point, if so exports as point instead\r\n    if(geometry.points.length===1){\r\n        return {\"type\": \"Point\",\"coordinates\": geometry.points[0]};\r\n    }else{\r\n        return { \"type\": \"MultiPoint\",\"coordinates\":geometry.points}; \r\n    }\r\n}\r\nfunction line(geometry){\r\n//checks if their are multiple paths or just one\r\n    if(geometry.paths.length===1){\r\n        return {\"type\": \"LineString\",\"coordinates\": geometry.paths[0]};\r\n    }else{\r\n        return { \"type\": \"MultiLineString\",\"coordinates\":geometry.paths}; \r\n    }\r\n}\r\nfunction poly(geometry){\r\n//first we check for some easy cases, like if their is only one ring\r\n    if(geometry.rings.length===1){\r\n        return {\"type\": \"Polygon\",\"coordinates\": geometry.rings};\r\n    }else{\r\n/*if it isn't that easy then we have to start checking ring direction, basically the ring goes clockwise its part of the polygon, if it goes counterclockwise it is a hole in the polygon, but geojson does it by haveing an array with the first element be the polygons and the next elements being holes in it*/\r\n        var ccc= dP(geometry.rings);\r\n        var d = ccc[0];\r\n        var dd = ccc[1];\r\n        var r=[];\r\n        if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d.length;\r\n            var i3 = 0;\r\n            while(l2>i3){\r\n             r.push([d[i3]]);   \r\n            }\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":r}; \r\n        }else if(d.length===1){\r\n/*if their is only one clockwise ring then we know all holes are in that poly*/\r\n            dd.unshift(d[0]);\r\n            return {\"type\": \"Polygon\",\"coordinates\": dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];\r\n        var dd =[];\r\n        var l = a.length;\r\n        var ii = 0;\r\n        while(l>ii){\r\n            if(c(a[ii])){\r\n                d.push(a[ii]);\r\n            }else{\r\n             dd.push(a[ii]);\r\n            }\r\n         ii++;\r\n        }\r\n    return [d,dd];\r\n}\r\nfunction c(a){\r\n//return true if clockwise\r\n var l = a.length-1;\r\n var i = 0;\r\n var o=0;\r\n\r\n while(l>i){\r\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i][1]);\r\n   \r\n     i++;\r\n }\r\n    return o<=0;\r\n}  \r\nfunction prop(a){\r\n var p = {};\r\n for(var k in a){\r\n  if(a[k]){\r\n   p[k]=a[k];   \r\n  }\r\n }\r\n return p;\r\n}\r\nif(cb){\r\n cb(outPut)\r\n}else{\r\nreturn outPut;  \r\n}\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":4028}]],"length":4028}
