{"ts":1344606532099,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * EXPORTS:\n *\t{\n *\tQRCode:QRCode\n *\tQRErrorCorrectLevel:QRErrorCorrectLevel\n *\t}\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of \n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n//---------------------------------------------------------------------\n// QRCode\n//---------------------------------------------------------------------\n\nexports.QRCode = QRCode;\n\nvar QRDataArray = (typeof Uint32Array == 'undefined'?Uint32Array:Array);\n\nfunction QRCode(typeNumber, errorCorrectLevel) {\n\tthis.typeNumber = typeNumber;\n\tthis.errorCorrectLevel = errorCorrectLevel;\n\tthis.modules = null;\n\tthis.moduleCount = 0;\n\tthis.dataCache = null;\n\tthis.dataList = new QRDataArray();\n}\n\nQRCode.prototype = {\n\t\n\taddData : function(data) {\n\t\tvar newData = new QR8bitByte(data);\n\t\tthis.dataList.push(newData);\n\t\tthis.dataCache = null;\n\t},\n\t\n\tisDark : function(row, col) {\n\t\tif (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {\n\t\t\tthrow new Error(row + \",\" + col);\n\t\t}\n\t\treturn this.modules[row][col];\n\t},\n\n\tgetModuleCount : function() {\n\t\treturn this.moduleCount;\n\t},\n\t\n\tmake : function() {\n\t\tthis.makeImpl(false, this.getBestMaskPattern() );\n\t},\n\t\n\tmakeImpl : function(test, maskPattern) {\n\t\t\n\t\tthis.moduleCount = this.typeNumber * 4 + 17;\n\t\tthis.modules = new QRDataArray(this.moduleCount);\n\t\t\n\t\tfor (var row = 0; row < this.moduleCount; row++) {\n\t\t\t\n\t\t\tthis.modules[row] = new QRDataArray(this.moduleCount);\n\t\t\t\n\t\t\tfor (var col = 0; col < this.moduleCount; col++) {\n\t\t\t\tthis.modules[row][col] = null;//(col + row) % 3;\n\t\t\t}\n\t\t}\n\t\n\t\tthis.setupPositionProbePattern(0, 0);\n\t\tthis.setupPositionProbePattern(this.moduleCount - 7, 0);\n\t\tthis.setupPositionProbePattern(0, this.moduleCount - 7);\n\t\tthis.setupPositionAdjustPattern();\n\t\tthis.setupTimingPattern();\n\t\tthis.setupTypeInfo(test, maskPattern);\n\t\t\n\t\tif (this.typeNumber >= 7) {\n\t\t\tthis.setupTypeNumber(test);\n\t\t}\n\t\n\t\tif (this.dataCache == null) {\n\t\t\tthis.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);\n\t\t}\n\t\n\t\tthis.mapData(this.dataCache, maskPattern);\n\t},\n\n\tsetupPositionProbePattern : function(row, col)  {\n\t\t\n\t\tfor (var r = -1; r <= 7; r++) {\n\t\t\t\n\t\t\tif (row + r <= -1 || this.moduleCount <= row + r) continue;\n\t\t\t\n\t\t\tfor (var c = -1; c <= 7; c++) {\n\t\t\t\t\n\t\t\t\tif (col + c <= -1 || this.moduleCount <= col + c) continue;\n\t\t\t\t\n\t\t\t\tif ( (0 <= r && r <= 6 && (c == 0 || c == 6) )\n\t\t\t\t\t\t|| (0 <= c && c <= 6 && (r == 0 || r == 6) )\n\t\t\t\t\t\t|| (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {\n\t\t\t\t\tthis.modules[row + r][col + c] = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.modules[row + r][col + c] = false;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\t\t\n\t},\n\t\n\tgetBestMaskPattern : function() {\n\t\n\t\tvar minLostPoint = 0;\n\t\tvar pattern = 0;\n\t\n\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\n\t\t\tthis.makeImpl(true, i);\n\t\n\t\t\tvar lostPoint = QRUtil.getLostPoint(this);\n\t\n\t\t\tif (i == 0 || minLostPoint >  lostPoint) {\n\t\t\t\tminLostPoint = lostPoint;\n\t\t\t\tpattern = i;\n\t\t\t}\n\t\t}\n\t\n\t\treturn pattern;\n\t},\n\n\tsetupTimingPattern : function() {\n\t\t\n\t\tfor (var r = 8; r < this.moduleCount - 8; r++) {\n\t\t\tif (this.modules[r][6] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.modules[r][6] = (r % 2 == 0);\n\t\t}\n\t\n\t\tfor (var c = 8; c < this.moduleCount - 8; c++) {\n\t\t\tif (this.modules[6][c] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.modules[6][c] = (c % 2 == 0);\n\t\t}\n\t},\n\t\n\tsetupPositionAdjustPattern : function() {\n\t\n\t\tvar pos = QRUtil.getPatternPosition(this.typeNumber);\n\t\tpos = pos || '';\n\t\tfor (var i = 0; i < pos.length; i++) {\n\t\t\n\t\t\tfor (var j = 0; j < pos.length; j++) {\n\t\t\t\n\t\t\t\tvar row = pos[i];\n\t\t\t\tvar col = pos[j];\n\t\t\t\t\n\t\t\t\tif (this.modules[row][col] != null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var r = -2; r <= 2; r++) {\n\t\t\t\t\n\t\t\t\t\tfor (var c = -2; c <= 2; c++) {\n\t\t\t\t\t\n\t\t\t\t\t\tif (r == -2 || r == 2 || c == -2 || c == 2 \n\t\t\t\t\t\t\t\t|| (r == 0 && c == 0) ) {\n\t\t\t\t\t\t\tthis.modules[row + r][col + c] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.modules[row + r][col + c] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tsetupTypeNumber : function(test) {\n\t\n\t\tvar bits = QRUtil.getBCHTypeNumber(this.typeNumber);\n\t\n\t\tfor (var i = 0; i < 18; i++) {\n\t\t\tvar mod = (!test && ( (bits >> i) & 1) == 1);\n\t\t\tthis.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;\n\t\t}\n\t\n\t\tfor (var i = 0; i < 18; i++) {\n\t\t\tvar mod = (!test && ( (bits >> i) & 1) == 1);\n\t\t\tthis.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;\n\t\t}\n\t},\n\t\n\tsetupTypeInfo : function(test, maskPattern) {\n\t\n\t\tvar data = (this.errorCorrectLevel << 3) | maskPattern;\n\t\tvar bits = QRUtil.getBCHTypeInfo(data);\n\t\n\t\t// vertical\t\t\n\t\tfor (var i = 0; i < 15; i++) {\n\t\n\t\t\tvar mod = (!test && ( (bits >> i) & 1) == 1);\n\t\n\t\t\tif (i < 6) {\n\t\t\t\tthis.modules[i][8] = mod;\n\t\t\t} else if (i < 8) {\n\t\t\t\tthis.modules[i + 1][8] = mod;\n\t\t\t} else {\n\t\t\t\tthis.modules[this.moduleCount - 15 + i][8] = mod;\n\t\t\t}\n\t\t}\n\t\n\t\t// horizontal\n\t\tfor (var i = 0; i < 15; i++) {\n\t\n\t\t\tvar mod = (!test && ( (bits >> i) & 1) == 1);\n\t\t\t\n\t\t\tif (i < 8) {\n\t\t\t\tthis.modules[8][this.moduleCount - i - 1] = mod;\n\t\t\t} else if (i < 9) {\n\t\t\t\tthis.modules[8][15 - i - 1 + 1] = mod;\n\t\t\t} else {\n\t\t\t\tthis.modules[8][15 - i - 1] = mod;\n\t\t\t}\n\t\t}\n\t\n\t\t// fixed module\n\t\tthis.modules[this.moduleCount - 8][8] = (!test);\n\t\n\t},\n\t\n\tmapData : function(data, maskPattern) {\n\t\t\n\t\tvar inc = -1;\n\t\tvar row = this.moduleCount - 1;\n\t\tvar bitIndex = 7;\n\t\tvar byteIndex = 0;\n\t\t\n\t\tfor (var col = this.moduleCount - 1; col > 0; col -= 2) {\n\t\n\t\t\tif (col == 6) col--;\n\t\n\t\t\twhile (true) {\n\t\n\t\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\t\t\n\t\t\t\t\tif (this.modules[row][col - c] == null) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar dark = false;\n\t\n\t\t\t\t\t\tif (byteIndex < data.length) {\n\t\t\t\t\t\t\tdark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar mask = QRUtil.getMask(maskPattern, row, col - c);\n\t\n\t\t\t\t\t\tif (mask) {\n\t\t\t\t\t\t\tdark = !dark;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.modules[row][col - c] = dark;\n\t\t\t\t\t\tbitIndex--;\n\t\n\t\t\t\t\t\tif (bitIndex == -1) {\n\t\t\t\t\t\t\tbyteIndex++;\n\t\t\t\t\t\t\tbitIndex = 7;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\trow += inc;\n\t\n\t\t\t\tif (row < 0 || this.moduleCount <= row) {\n\t\t\t\t\trow -= inc;\n\t\t\t\t\tinc = -inc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n};\n\nQRCode.PAD0 = 0xEC;\nQRCode.PAD1 = 0x11;\n\nQRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {\n\t\n\tvar rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);\n\t\n\tvar buffer = new QRBitBuffer();\n\t\n\tfor (var i = 0; i < dataList.length; i++) {\n\t\tvar data = dataList[i];\n\t\tbuffer.put(data.mode, 4);\n\t\tbuffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber) );\n\t\tdata.write(buffer);\n\t}\n\n\t// calc num max data.\n\tvar totalDataCount = 0;\n\tfor (var i = 0; i < rsBlocks.length; i++) {\n\t\ttotalDataCount += rsBlocks[i].dataCount;\n\t}\n\n\tif (buffer.getLengthInBits() > totalDataCount * 8) {\n\t\tthrow new Error(\"code length overflow. (\"\n\t\t\t+ buffer.getLengthInBits()\n\t\t\t+ \">\"\n\t\t\t+  totalDataCount * 8\n\t\t\t+ \")\");\n\t}\n\n\t// end code\n\tif (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n\t\tbuffer.put(0, 4);\n\t}\n\n\t// padding\n\twhile (buffer.getLengthInBits() % 8 != 0) {\n\t\tbuffer.putBit(false);\n\t}\n\n\t// padding\n\twhile (true) {\n\t\t\n\t\tif (buffer.getLengthInBits() >= totalDataCount * 8) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer.put(QRCode.PAD0, 8);\n\t\t\n\t\tif (buffer.getLengthInBits() >= totalDataCount * 8) {\n\t\t\tbreak;\n\t\t}\n\t\tbuffer.put(QRCode.PAD1, 8);\n\t}\n\n\treturn QRCode.createBytes(buffer, rsBlocks);\n};\n\nQRCode.createBytes = function(buffer, rsBlocks) {\n\n\tvar offset = 0;\n\t\n\tvar maxDcCount = 0;\n\tvar maxEcCount = 0;\n\t\n\tvar dcdata = new QRDataArray(rsBlocks.length);\n\tvar ecdata = new QRDataArray(rsBlocks.length);\n\t\n\tfor (var r = 0; r < rsBlocks.length; r++) {\n\n\t\tvar dcCount = rsBlocks[r].dataCount;\n\t\tvar ecCount = rsBlocks[r].totalCount - dcCount;\n\n\t\tmaxDcCount = Math.max(maxDcCount, dcCount);\n\t\tmaxEcCount = Math.max(maxEcCount, ecCount);\n\t\t\n\t\tdcdata[r] = new QRDataArray(dcCount);\n\t\t\n\t\tfor (var i = 0; i < dcdata[r].length; i++) {\n\t\t\tdcdata[r][i] = 0xff & buffer.buffer[i + offset];\n\t\t}\n\t\toffset += dcCount;\n\t\t\n\t\tvar rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n\t\tvar rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);\n\n\t\tvar modPoly = rawPoly.mod(rsPoly);\n\t\tecdata[r] = new QRDataArray(rsPoly.getLength() - 1);\n\t\tfor (var i = 0; i < ecdata[r].length; i++) {\n            var modIndex = i + modPoly.getLength() - ecdata[r].length;\n\t\t\tecdata[r][i] = (modIndex >= 0)? modPoly.get(modIndex) : 0;\n\t\t}\n\n\t}\n\t\n\tvar totalCodeCount = 0;\n\tfor (var i = 0; i < rsBlocks.length; i++) {\n\t\ttotalCodeCount += rsBlocks[i].totalCount;\n\t}\n\n\tvar data = new QRDataArray(totalCodeCount);\n\tvar index = 0;\n\n\tfor (var i = 0; i < maxDcCount; i++) {\n\t\tfor (var r = 0; r < rsBlocks.length; r++) {\n\t\t\tif (i < dcdata[r].length) {\n\t\t\t\tdata[index++] = dcdata[r][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (var i = 0; i < maxEcCount; i++) {\n\t\tfor (var r = 0; r < rsBlocks.length; r++) {\n\t\t\tif (i < ecdata[r].length) {\n\t\t\t\tdata[index++] = ecdata[r][i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn data;\n\n};\n\n//---------------------------------------------------------------------\n// QR8bitByte\n//---------------------------------------------------------------------\n\nfunction QR8bitByte(data) {\n  this.mode = QRMode.MODE_8BIT_BYTE;\n  this.data = data;\n}\n\nQR8bitByte.prototype = {\n\n  getLength : function(buffer) {\n    return this.data.length;\n  },\n  \n  write : function(buffer) {\n    for (var i = 0; i < this.data.length; i++) {\n      // not JIS ...\n      buffer.put(this.data.charCodeAt(i), 8);\n    }\n  }\n};\n\n//---------------------------------------------------------------------\n// QRMode\n//---------------------------------------------------------------------\n\nvar QRMode = {\n\tMODE_NUMBER :\t\t1 << 0,\n\tMODE_ALPHA_NUM : \t1 << 1,\n\tMODE_8BIT_BYTE : \t1 << 2,\n\tMODE_KANJI :\t\t1 << 3\n};\n\n//---------------------------------------------------------------------\n// QRErrorCorrectLevel\n//---------------------------------------------------------------------\n//exported\n\nvar QRErrorCorrectLevel = exports.QRErrorCorrectLevel = {\n\tL : 1,\n\tM : 0,\n\tQ : 3,\n\tH : 2\n};\n\n//---------------------------------------------------------------------\n// QRMaskPattern\n//---------------------------------------------------------------------\n\nvar QRMaskPattern =  {\n\tPATTERN000 : 0,\n\tPATTERN001 : 1,\n\tPATTERN010 : 2,\n\tPATTERN011 : 3,\n\tPATTERN100 : 4,\n\tPATTERN101 : 5,\n\tPATTERN110 : 6,\n\tPATTERN111 : 7\n};\n\n//---------------------------------------------------------------------\n// QRUtil\n//---------------------------------------------------------------------\n \nvar QRUtil = {\n\n    PATTERN_POSITION_TABLE : [\n\t    [],\n\t    [6, 18],\n\t    [6, 22],\n\t    [6, 26],\n\t    [6, 30],\n\t    [6, 34],\n\t    [6, 22, 38],\n\t    [6, 24, 42],\n\t    [6, 26, 46],\n\t    [6, 28, 50],\n\t    [6, 30, 54],\t\t\n\t    [6, 32, 58],\n\t    [6, 34, 62],\n\t    [6, 26, 46, 66],\n\t    [6, 26, 48, 70],\n\t    [6, 26, 50, 74],\n\t    [6, 30, 54, 78],\n\t    [6, 30, 56, 82],\n\t    [6, 30, 58, 86],\n\t    [6, 34, 62, 90],\n\t    [6, 28, 50, 72, 94],\n\t    [6, 26, 50, 74, 98],\n\t    [6, 30, 54, 78, 102],\n\t    [6, 28, 54, 80, 106],\n\t    [6, 32, 58, 84, 110],\n\t    [6, 30, 58, 86, 114],\n\t    [6, 34, 62, 90, 118],\n\t    [6, 26, 50, 74, 98, 122],\n\t    [6, 30, 54, 78, 102, 126],\n\t    [6, 26, 52, 78, 104, 130],\n\t    [6, 30, 56, 82, 108, 134],\n\t    [6, 34, 60, 86, 112, 138],\n\t    [6, 30, 58, 86, 114, 142],\n\t    [6, 34, 62, 90, 118, 146],\n\t    [6, 30, 54, 78, 102, 126, 150],\n\t    [6, 24, 50, 76, 102, 128, 154],\n\t    [6, 28, 54, 80, 106, 132, 158],\n\t    [6, 32, 58, 84, 110, 136, 162],\n\t    [6, 26, 54, 82, 110, 138, 166],\n\t    [6, 30, 58, 86, 114, 142, 170]\n    ],\n\n    G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),\n    G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),\n    G15_MASK : (1 << 14) | (1 << 12) | (1 << 10)\t| (1 << 4) | (1 << 1),\n\n    getBCHTypeInfo : function(data) {\n\t    var d = data << 10;\n\t    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {\n\t\t    d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) ); \t\n\t    }\n\t    return ( (data << 10) | d) ^ QRUtil.G15_MASK;\n    },\n\n    getBCHTypeNumber : function(data) {\n\t    var d = data << 12;\n\t    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {\n\t\t    d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) ); \t\n\t    }\n\t    return (data << 12) | d;\n    },\n\n    getBCHDigit : function(data) {\n\n\t    var digit = 0;\n\n\t    while (data != 0) {\n\t\t    digit++;\n\t\t    data >>>= 1;\n\t    }\n\n\t    return digit;\n    },\n\n    getPatternPosition : function(typeNumber) {\n\t    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];\n    },\n\n    getMask : function(maskPattern, i, j) {\n\t    \n\t    switch (maskPattern) {\n\t\t    \n\t    case QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0;\n\t    case QRMaskPattern.PATTERN001 : return i % 2 == 0;\n\t    case QRMaskPattern.PATTERN010 : return j % 3 == 0;\n\t    case QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0;\n\t    case QRMaskPattern.PATTERN100 : return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0;\n\t    case QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0;\n\t    case QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0;\n\t    case QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0;\n\n\t    default :\n\t\t    throw new Error(\"bad maskPattern:\" + maskPattern);\n\t    }\n    },\n\n    getErrorCorrectPolynomial : function(errorCorrectLength) {\n\n\t    var a = new QRPolynomial([1], 0);\n\n\t    for (var i = 0; i < errorCorrectLength; i++) {\n\t\t    a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0) );\n\t    }\n\n\t    return a;\n    },\n\n    getLengthInBits : function(mode, type) {\n\n\t    if (1 <= type && type < 10) {\n\n\t\t    // 1 - 9\n\n\t\t    switch(mode) {\n\t\t    case QRMode.MODE_NUMBER \t: return 10;\n\t\t    case QRMode.MODE_ALPHA_NUM \t: return 9;\n\t\t    case QRMode.MODE_8BIT_BYTE\t: return 8;\n\t\t    case QRMode.MODE_KANJI  \t: return 8;\n\t\t    default :\n\t\t\t    throw new Error(\"mode:\" + mode);\n\t\t    }\n\n\t    } else if (type < 27) {\n\n\t\t    // 10 - 26\n\n\t\t    switch(mode) {\n\t\t    case QRMode.MODE_NUMBER \t: return 12;\n\t\t    case QRMode.MODE_ALPHA_NUM \t: return 11;\n\t\t    case QRMode.MODE_8BIT_BYTE\t: return 16;\n\t\t    case QRMode.MODE_KANJI  \t: return 10;\n\t\t    default :\n\t\t\t    throw new Error(\"mode:\" + mode);\n\t\t    }\n\n\t    } else if (type < 41) {\n\n\t\t    // 27 - 40\n\n\t\t    switch(mode) {\n\t\t    case QRMode.MODE_NUMBER \t: return 14;\n\t\t    case QRMode.MODE_ALPHA_NUM\t: return 13;\n\t\t    case QRMode.MODE_8BIT_BYTE\t: return 16;\n\t\t    case QRMode.MODE_KANJI  \t: return 12;\n\t\t    default :\n\t\t\t    throw new Error(\"mode:\" + mode);\n\t\t    }\n\n\t    } else {\n\t\t    throw new Error(\"type:\" + type);\n\t    }\n    },\n\n    getLostPoint : function(qrCode) {\n\t    \n\t    var moduleCount = qrCode.getModuleCount();\n\t    \n\t    var lostPoint = 0;\n\t    \n\t    // LEVEL1\n\t    \n\t    for (var row = 0; row < moduleCount; row++) {\n\n\t\t    for (var col = 0; col < moduleCount; col++) {\n\n\t\t\t    var sameCount = 0;\n\t\t\t    var dark = qrCode.isDark(row, col);\n\n\t\t\t\tfor (var r = -1; r <= 1; r++) {\n\n\t\t\t\t    if (row + r < 0 || moduleCount <= row + r) {\n\t\t\t\t\t    continue;\n\t\t\t\t    }\n\n\t\t\t\t    for (var c = -1; c <= 1; c++) {\n\n\t\t\t\t\t    if (col + c < 0 || moduleCount <= col + c) {\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    if (r == 0 && c == 0) {\n\t\t\t\t\t\t    continue;\n\t\t\t\t\t    }\n\n\t\t\t\t\t    if (dark == qrCode.isDark(row + r, col + c) ) {\n\t\t\t\t\t\t    sameCount++;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\n\t\t\t    if (sameCount > 5) {\n\t\t\t\t    lostPoint += (3 + sameCount - 5);\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    // LEVEL2\n\n\t    for (var row = 0; row < moduleCount - 1; row++) {\n\t\t    for (var col = 0; col < moduleCount - 1; col++) {\n\t\t\t    var count = 0;\n\t\t\t    if (qrCode.isDark(row,     col    ) ) count++;\n\t\t\t    if (qrCode.isDark(row + 1, col    ) ) count++;\n\t\t\t    if (qrCode.isDark(row,     col + 1) ) count++;\n\t\t\t    if (qrCode.isDark(row + 1, col + 1) ) count++;\n\t\t\t    if (count == 0 || count == 4) {\n\t\t\t\t    lostPoint += 3;\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    // LEVEL3\n\n\t    for (var row = 0; row < moduleCount; row++) {\n\t\t    for (var col = 0; col < moduleCount - 6; col++) {\n\t\t\t    if (qrCode.isDark(row, col)\n\t\t\t\t\t    && !qrCode.isDark(row, col + 1)\n\t\t\t\t\t    &&  qrCode.isDark(row, col + 2)\n\t\t\t\t\t    &&  qrCode.isDark(row, col + 3)\n\t\t\t\t\t    &&  qrCode.isDark(row, col + 4)\n\t\t\t\t\t    && !qrCode.isDark(row, col + 5)\n\t\t\t\t\t    &&  qrCode.isDark(row, col + 6) ) {\n\t\t\t\t    lostPoint += 40;\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    for (var col = 0; col < moduleCount; col++) {\n\t\t    for (var row = 0; row < moduleCount - 6; row++) {\n\t\t\t    if (qrCode.isDark(row, col)\n\t\t\t\t\t    && !qrCode.isDark(row + 1, col)\n\t\t\t\t\t    &&  qrCode.isDark(row + 2, col)\n\t\t\t\t\t    &&  qrCode.isDark(row + 3, col)\n\t\t\t\t\t    &&  qrCode.isDark(row + 4, col)\n\t\t\t\t\t    && !qrCode.isDark(row + 5, col)\n\t\t\t\t\t    &&  qrCode.isDark(row + 6, col) ) {\n\t\t\t\t    lostPoint += 40;\n\t\t\t    }\n\t\t    }\n\t    }\n\n\t    // LEVEL4\n\t    \n\t    var darkCount = 0;\n\n\t    for (var col = 0; col < moduleCount; col++) {\n\t\t    for (var row = 0; row < moduleCount; row++) {\n\t\t\t    if (qrCode.isDark(row, col) ) {\n\t\t\t\t    darkCount++;\n\t\t\t    }\n\t\t    }\n\t    }\n\t    \n\t    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n\t    lostPoint += ratio * 10;\n\n\t    return lostPoint;\t\t\n    }\n\n};\n\n\n//---------------------------------------------------------------------\n// QRMath\n//---------------------------------------------------------------------\n\nvar QRMath = {\n\n\tglog : function(n) {\n\t\n\t\tif (n < 1) {\n\t\t\tthrow new Error(\"glog(\" + n + \")\");\n\t\t}\n\t\t\n\t\treturn QRMath.LOG_TABLE[n];\n\t},\n\t\n\tgexp : function(n) {\n\t\n\t\twhile (n < 0) {\n\t\t\tn += 255;\n\t\t}\n\t\n\t\twhile (n >= 256) {\n\t\t\tn -= 255;\n\t\t}\n\t\n\t\treturn QRMath.EXP_TABLE[n];\n\t},\n\t\n\tEXP_TABLE : new Array(256),\n\t\n\tLOG_TABLE : new Array(256)\n\n};\n\t\nfor (var i = 0; i < 8; i++) {\n\tQRMath.EXP_TABLE[i] = 1 << i;\n}\nfor (var i = 8; i < 256; i++) {\n\tQRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4]\n\t\t^ QRMath.EXP_TABLE[i - 5]\n\t\t^ QRMath.EXP_TABLE[i - 6]\n\t\t^ QRMath.EXP_TABLE[i - 8];\n}\nfor (var i = 0; i < 255; i++) {\n\tQRMath.LOG_TABLE[QRMath.EXP_TABLE[i] ] = i;\n}\n\n//---------------------------------------------------------------------\n// QRPolynomial\n//---------------------------------------------------------------------\n\nfunction QRPolynomial(num, shift) {\n\n\tif (num.length == undefined) {\n\t\tthrow new Error(num.length + \"/\" + shift);\n\t}\n\n\tvar offset = 0;\n\n\twhile (offset < num.length && num[offset] == 0) {\n\t\toffset++;\n\t}\n\n\tthis.num = new Array(num.length - offset + shift);\n\tfor (var i = 0; i < num.length - offset; i++) {\n\t\tthis.num[i] = num[i + offset];\n\t}\n}\n\nQRPolynomial.prototype = {\n\n\tget : function(index) {\n\t\treturn this.num[index];\n\t},\n\t\n\tgetLength : function() {\n\t\treturn this.num.length;\n\t},\n\t\n\tmultiply : function(e) {\n\t\n\t\tvar num = new Array(this.getLength() + e.getLength() - 1);\n\t\n\t\tfor (var i = 0; i < this.getLength(); i++) {\n\t\t\tfor (var j = 0; j < e.getLength(); j++) {\n\t\t\t\tnum[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i) ) + QRMath.glog(e.get(j) ) );\n\t\t\t}\n\t\t}\n\t\n\t\treturn new QRPolynomial(num, 0);\n\t},\n\t\n\tmod : function(e) {\n\t\n\t\tif (this.getLength() - e.getLength() < 0) {\n\t\t\treturn this;\n\t\t}\n\t\n\t\tvar ratio = QRMath.glog(this.get(0) ) - QRMath.glog(e.get(0) );\n\t\n\t\tvar num = new Array(this.getLength() );\n\t\t\n\t\tfor (var i = 0; i < this.getLength(); i++) {\n\t\t\tnum[i] = this.get(i);\n\t\t}\n\t\t\n\t\tfor (var i = 0; i < e.getLength(); i++) {\n\t\t\tnum[i] ^= QRMath.gexp(QRMath.glog(e.get(i) ) + ratio);\n\t\t}\n\t\n\t\t// recursive call\n\t\treturn new QRPolynomial(num, 0).mod(e);\n\t}\n};\n\n//---------------------------------------------------------------------\n// QRRSBlock\n//---------------------------------------------------------------------\n\nfunction QRRSBlock(totalCount, dataCount) {\n\tthis.totalCount = totalCount;\n\tthis.dataCount  = dataCount;\n}\n\nQRRSBlock.RS_BLOCK_TABLE = [\n// L\n// M\n// Q\n// H\n\n// 1\n[1, 26, 19],\n[1, 26, 16],\n[1, 26, 13],\n[1, 26, 9],\n// 2\n[1, 44, 34],\n[1, 44, 28],\n[1, 44, 22],\n[1, 44, 16],\n// 3\n[1, 70, 55],\n[1, 70, 44],\n[2, 35, 17],\n[2, 35, 13],\n// 4\t\t\n[1, 100, 80],\n[2, 50, 32],\n[2, 50, 24],\n[4, 25, 9],\n// 5\n[1, 134, 108],\n[2, 67, 43],\n[2, 33, 15, 2, 34, 16],\n[2, 33, 11, 2, 34, 12],\n// 6\n[2, 86, 68],\n[4, 43, 27],\n[4, 43, 19],\n[4, 43, 15],\n// 7\t\t\n[2, 98, 78],\n[4, 49, 31],\n[2, 32, 14, 4, 33, 15],\n[4, 39, 13, 1, 40, 14],\n// 8\n[2, 121, 97],\n[2, 60, 38, 2, 61, 39],\n[4, 40, 18, 2, 41, 19],\n[4, 40, 14, 2, 41, 15],\n// 9\n[2, 146, 116],\n[3, 58, 36, 2, 59, 37],\n[4, 36, 16, 4, 37, 17],\n[4, 36, 12, 4, 37, 13],\n// 10\t\t\n[2, 86, 68, 2, 87, 69],\n[4, 69, 43, 1, 70, 44],\n[6, 43, 19, 2, 44, 20],\n[6, 43, 15, 2, 44, 16]\n//NOTE added by Ryan Day.to make greater than version 10 qrcodes\n// this table starts on page 40 of the spec PDF. google ISO/IEC 18004\n// 11\n,[4,101,81]\n,[1,80,50,4,81,51]\n,[4,50,22,4,51,23]\n,[3,36,12,8,37,13]\n//12\n,[2,116,92,2,117,93]\n,[6,58,36,2,59,37]\n,[4,46,20,6,47,21]\n,[7,42,14,4,43,15]\n//13\n,[4,133,107]\n,[8,59,37,1,60,38]\n,[8,44,20,4,45,21]\n,[12,33,11,4,34,12]\n//14\n,[3,145,115,1,146,116]\n,[4,64,40,5,65,41]\n,[11,36,16,5,37,17]\n,[11,36,12,5,37,13]\n//15\n,[5,109,87,1,110,88]\n,[5,65,41,5,66,42]\n,[5,54,24,7,55,25]\n,[11,36,12,7,37,13]\n//16\n,[5,122,98,1,123,99]\n,[7,73,45,3,74,46]\n,[15,43,19,2,44,20]\n,[3,45,15,13,46,16]\n//17\n,[1,135,107,5,136,108]\n,[10,74,46,1,75,47]\n,[1,50,22,15,51,23]\n,[2,42,14,17,43,15]\n//18\n,[5,150,120,1,151,121]\n,[9,69,43,4,70,44]\n,[17,50,22,1,51,23]\n,[2,42,14,19,43,15]\n//19\n,[3,141,113,4,142,114]\n,[3,70,44,11,71,45]\n,[17,47,21,4,48,22]\n,[9,39,13,16,40,14]\n//20\n,[3,135,107,5,136,108]\n,[3,67,41,13,68,42]\n,[15,54,24,5,55,25]\n,[15,43,15,10,44,16]\n//21\n,[4,144,116,4,145,117]\n,[17,68,42]\n,[17,50,22,6,51,23]\n,[19,46,16,6,47,17]\n//22\n,[2,139,111,7,140,112]\n,[17,74,46]\n,[7,54,24,16,55,25]\n,[34,37,13]\n//23\n,[4,151,121,5,152,122]\n,[4,75,47,14,76,48]\n,[11,54,24,14,55,25]\n,[16,45,15,14,46,16]\n//24\n,[6,147,117,4,148,118]\n,[6,73,45,14,74,46]\n,[11,54,24,16,55,25]\n,[30,46,16,2,47,17]\n//25\n,[8,132,106,4,133,107]\n,[8,75,47,13,76,48]\n,[7,54,24,22,55,25]\n,[22,45,15,13,46,16]\n//26\n,[10,142,114,2,143,115]\n,[19,74,46,4,75,47]\n,[28,50,22,6,51,23]\n,[33,46,16,4,47,17]\n//27\n,[8,152,122,4,153,123]\n,[22,73,45,3,74,46]\n,[8,53,23,26,54,24]\n,[12,45,15,28,46,16]\n//28\n,[3,147,117,10,148,118]\n,[3,73,45,23,74,46]\n,[4,54,24,31,55,25]\n,[11,45,15,31,46,16]\n//29\n,[7,146,116,7,147,117]\n,[21,73,45,7,74,46]\n,[1,53,23,37,54,24]\n,[19,45,15,26,46,16]\n//30\n,[5,145,115,10,146,116]\n,[19,75,47,10,76,48]\n,[15,54,24,25,55,25]\n,[23,45,15,25,46,16]\n//31\n,[13,145,115,3,146,116]\n,[2,74,46,29,75,47]\n,[42,54,24,1,55,25]\n,[23,45,15,28,46,16]\n//32\n,[17,145,115]\n,[10,74,46,23,75,47]\n,[10,54,24,35,55,25]\n,[19,45,15,35,46,16]\n//33\n,[17,145,115,1,146,116]\n,[14,74,46,21,75,47]\n,[29,54,24,19,55,25]\n,[11,45,15,46,46,16]\n//34\n,[13,145,115,6,146,116]\n,[14,74,46,23,75,47]\n,[44,54,24,7,55,25]\n,[59,46,16,1,47,17]\n//35\n,[12,151,121,7,152,122]\n,[12,75,47,26,76,48]\n,[39,54,24,14,55,25]\n,[22,45,15,41,46,16]\n//36\n,[6,151,121,14,152,122]\n,[6,75,47,34,76,48]\n,[46,54,24,10,55,25]\n,[2,45,15,64,46,16]\n//37\n,[17,152,122,4,153,123]\n,[29,74,46,14,75,47]\n,[49,54,24,10,55,25]\n,[24,45,15,46,46,16]\n//38\n,[4,152,122,18,153,123]\n,[13,74,46,32,75,47]\n,[48,54,24,14,55,25]\n,[42,45,15,32,46,16]\n//39\n,[20,147,117,4,148,118]\n,[40,75,47,7,76,48]\n,[43,54,24,22,55,25]\n,[10,45,15,67,46,16]\n//40\n,[19,148,118,6,149,119]\n,[18,75,47,31,76,48]\n,[34,54,24,34,55,25]\n,[20,45,15,61,46,16]\t\n];\n\nQRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {\n\t\n\tvar rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);\n\t\n\tif (rsBlock == undefined) {\n\t\tthrow new Error(\"bad rs block @ typeNumber:\" + typeNumber + \"/errorCorrectLevel:\" + errorCorrectLevel);\n\t}\n\n\tvar length = rsBlock.length / 3;\n\t\n\tvar list = new Array();\n\t\n\tfor (var i = 0; i < length; i++) {\n\n\t\tvar count = rsBlock[i * 3 + 0];\n\t\tvar totalCount = rsBlock[i * 3 + 1];\n\t\tvar dataCount  = rsBlock[i * 3 + 2];\n\n\t\tfor (var j = 0; j < count; j++) {\n\t\t\tlist.push(new QRRSBlock(totalCount, dataCount) );\t\n\t\t}\n\t}\n\t\n\treturn list;\n}\n\nQRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {\n\n\tswitch(errorCorrectLevel) {\n\tcase QRErrorCorrectLevel.L :\n\t\treturn QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n\tcase QRErrorCorrectLevel.M :\n\t\treturn QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n\tcase QRErrorCorrectLevel.Q :\n\t\treturn QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n\tcase QRErrorCorrectLevel.H :\n\t\treturn QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n\tdefault :\n\t\treturn undefined;\n\t}\n}\n\n//---------------------------------------------------------------------\n// QRBitBuffer\n//---------------------------------------------------------------------\n\nfunction QRBitBuffer() {\n\tthis.buffer = new Array();\n\tthis.length = 0;\n}\n\nQRBitBuffer.prototype = {\n\n\tget : function(index) {\n\t\tvar bufIndex = Math.floor(index / 8);\n\t\treturn ( (this.buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;\n\t},\n\t\n\tput : function(num, length) {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tthis.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);\n\t\t}\n\t},\n\t\n\tgetLengthInBits : function() {\n\t\treturn this.length;\n\t},\n\t\n\tputBit : function(bit) {\n\t\n\t\tvar bufIndex = Math.floor(this.length / 8);\n\t\tif (this.buffer.length <= bufIndex) {\n\t\t\tthis.buffer.push(0);\n\t\t}\n\t\n\t\tif (bit) {\n\t\t\tthis.buffer[bufIndex] |= (0x80 >>> (this.length % 8) );\n\t\t}\n\t\n\t\tthis.length++;\n\t}\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":25677}]],"length":25677}
{"contributors":[],"silentsave":false,"ts":1344606544503,"patch":[[{"diffs":[[0,"--\n\n"],[-1,"exports.QRCode = QRCode;"],[0,"\n\nva"]],"start1":918,"start2":918,"length1":32,"length2":8},{"diffs":[[0,"length++;\n\t}\n};\n"],[1,"function QRCodeDraw(){}\n\nQRCodeDraw.prototype = {\n  scale:4,//4 px module size\n  defaultMargin:20,\n  marginScaleFactor:5,\n  Array:(typeof Uint32Array == 'undefined'?Uint32Array:Array),\n  // you may configure the error behavior for input string too long\n  errorBehavior:{\n    length:'trim'\n  },\n  color:{\n    dark:'black',\n    light:'white'\n  },\n  defaultErrorCorrectLevel:QRCodeLib.QRErrorCorrectLevel.H,\n  QRErrorCorrectLevel:QRCodeLib.QRErrorCorrectLevel,\n  draw:function(canvas,text,options,cb){\n    var cb,\n        options = {},\n        level,\n        error;\n\n    \n    var args = Array.prototype.slice.call(arguments);\n    cb = args.pop(); \n    canvas = args.shift();\n    options = args.shift()||{};\n\n    \n    if(typeof cb != 'function') {\n      //enforce callback api just in case the processing can be made async in the future\n      // or support proc open to libqrencode\n      throw new Error('callback required');\n    }\n    \n    if(typeof options !== \"object\"){\n      options.errorCorrectLevel = options;\n    }\n    \n\n    this.QRVersion(text,options.errorCorrectLevel||this.QRErrorCorrectLevel.H,options.version,function(e,t,l,ec){\n      text = t,level = l,error = e,errorCorrectLevel = ec;\n    });\n\n    this.scale = options.scale||this.scale;\n    this.margin = options.margin||this.scale*2;\n    \n    if(!level) {\n      //if we are unable to find an appropriate qr level error out\n      cb(error,canvas);\n      return;\n    }\n\n    //create qrcode!\n    try{\n      \n      var qr = new QRCodeLib.QRCode(level, errorCorrectLevel)\n      , scale = this.scale||4\n      , ctx = canvas.getContext('2d')\n      , width = 0;\n\n      qr.addData(text);\n      qr.make();\n\n      var margin = this.marginWidth();      \n      var currenty = margin;\n      \n      width = this.dataWidth(qr)+ margin*2;\n      \n      this.resetCanvas(canvas,ctx,width);\n\n      for (var r = 0,rl=qr.getModuleCount(); r < rl; r++) {\n        var currentx = margin;\n        for (var c = 0,cl=qr.getModuleCount(); c < cl; c++) {\n          if (qr.isDark(r, c) ) {\n            ctx.fillStyle = this.color.dark;\n            ctx.fillRect (currentx, currenty, scale, scale);\n          } else if(this.color.light){\n            //if falsy configured color\n            ctx.fillStyle = this.color.light;\n            ctx.fillRect (currentx, currenty, scale, scale);\n          }\n          currentx += scale;\n        }\n        currenty += scale;\n      }\n    } catch (e) {\n      error = e;\n    }\n    \n    cb(error,canvas,width);    \n  },\n  drawBitArray:function(text/*,errorCorrectLevel,options,cb*/) {\n\n    var args = Array.prototype.slice.call(arguments),\n      cb = args.pop(),\n      text = args.shift(),\n      errorCorrectLevel = args.shift(),\n      options = args.shift() || {};\n\n    //argument processing\n    if(typeof cb != 'function') {\n      //enforce callback api just in case the processing can be made async in the future\n      // or support proc open to libqrencode\n      throw new Error('callback required as last argument');\n    }\n    \n    cb = arguments[arguments.length-1]; \n    \n    if(arguments.length > 2){\n      errorCorrectLevel = arguments[2];\n    }\n\n\n    //this interface kinda sucks - there is very small likelyhood of this ever being async\n    this.QRVersion(text,errorCorrectLevel,(options||{}).version,function(e,t,l,ec){\n      text = t,level = l,error = e,errorCorrectLevel = ec;\n    });\n\n   //console.log(text,level,error,errorCorrectLevel); \n\n   if(!level) {\n      //if we are unable to find an appropriate qr level error out\n      cb(error,[],0);\n      return;\n    }\n\n    //create qrcode!\n    try{\n\n      var qr = new QRCodeLib.QRCode(level, errorCorrectLevel)\n      , scale = this.scale||4\n      , width = 0,bits,bitc=0,currenty=0;\n      \n      qr.addData(text);\n      qr.make();\n      \n      width = this.dataWidth(qr,1);\n      bits = new this.Array(width*width);\n\n      \n      for (var r = 0,rl=qr.getModuleCount(); r < rl; r++) {\n        for (var c = 0,cl=qr.getModuleCount(); c < cl; c++) {\n          if (qr.isDark(r, c) ) {\n            bits[bitc] = 1;\n          } else {\n            bits[bitc] = 0;\n          }\n          bitc++;\n        }\n      }\n    } catch (e) {\n      error = e;\n      console.log(e.stack);\n    }\n    \n    cb(error,bits,width);\n  },\n  QRVersion:function(text,errorCorrectLevel,version,cb){\n    var c = text.length, \n        error,\n        errorCorrectLevel = this.QRErrorCorrectLevel[errorCorrectLevel]||this.defaultErrorCorrectLevel,\n        errorCorrectIndex = [1,0,3,2],//fix odd mapping to order in table\n        keys = ['L','M','Q','H'],\n        capacity = 0,\n        versionSpecified = false;\n\n        \n    if(typeof version !== \"undefined\" && version !== null) {\n      versionSpecified = true;\n    }\n    //TODO ADD THROW FOR INVALID errorCorrectLevel...?\n    \n    if(versionSpecified){\n      console.log('SPECIFIED VERSION! ',version);\n      //i have specified a version. this will give me a fixed size qr code. version must be valid. 1-40\n      capacity = QRVersionCapacityTable[version][errorCorrectIndex[errorCorrectLevel]];\n      \n    } else {\n      //figure out what version can hold the amount of text\n      for(var i=0,j=QRVersionCapacityTable.length;i<j;i++) {\n        capacity = QRVersionCapacityTable[i][errorCorrectIndex[errorCorrectLevel]];\n        if(c < QRVersionCapacityTable[i][errorCorrectIndex[errorCorrectLevel]]){\n          version = i+1;\n          break;\n        }\n      }\n      //if not version set to max\n      if(!version) {\n        version = QRVersionCapacityTable.length-1;\n      }\n    }\n    \n    if(capacity < c){\n      if(this.errorBehavior.length == 'trim'){\n        text = text.substr(0,capacity);\n        level = QRVersionCapacityTable.length; \n      } else {\n        error = new Error('input string too long for error correction '\n          +keys[errorCorrectIndex[errorCorrectLevel]]\n          +' max length '\n          + capacity\n          +' for qrcode version '+version\n        );\n      }\n    }\n  \n    if(cb) {\n      cb(error,text,version,errorCorrectLevel);\n    }\n    return version;\n  },\n  marginWidth:function(){\n    var margin = this.defaultMargin;\n    this.scale = this.scale||4;\n    //elegant white space next to code is required by spec\n    if (this.scale * this.marginScaleFactor > margin) {\n      margin = this.scale * this.marginScaleFactor;\n    }\n    return margin;\n  },\n  dataWidth:function(qr,scale){\n    return qr.getModuleCount()*(scale||this.scale||4);\n  },\n  resetCanvas:function(canvas,ctx,width){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    if(!canvas.style) canvas.style = {};\n    canvas.style.height = canvas.height = width;//square!\n    canvas.style.width = canvas.width = width;\n    \n    if(this.color.light){\n      ctx.fillStyle = this.color.light; \n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    } else {\n      //support transparent backgrounds?\n      //not exactly to spec but i really would like someone to be able to add a background with heavily reduced luminosity for simple branding\n      //i could just ditch this because you could also just set #******00 as the color =P\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n    }\n  }\n};\n\n"]],"start1":25637,"start2":25637,"length1":16,"length2":7154}]],"length":32791,"saved":false}
{"ts":1344606594544,"patch":[[{"diffs":[[0,"vel "],[-1,"= exports.QRErrorCorrectLevel"],[0," = {"]],"start1":10335,"start2":10335,"length1":37,"length2":8}]],"length":32762,"saved":false}
