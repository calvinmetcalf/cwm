{"ts":1344606502193,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n* copyright 2010 Ryan Day\n* http://github.com/soldair/node-qrcode\n*\n* Licensed under the MIT license:\n*   http://www.opensource.org/licenses/mit-license.php\n*\n* canvas example and fallback support example provided by Joshua Koo\n*\thttp://jabtunes.com/labs/qrcode.html\n*\t\"Instant QRCode Mashup by Joshua Koo!\"\n*\tas far as i can tell the page and the code on the page are public domain \n*\t\n* original table example and library provided by Kazuhiko Arase\n*\thttp://d-project.googlecode.com/svn/trunk/misc/qrcode/js/\n*\n*/\n\nvar QRCodeLib = require('./qrcode.js');\nvar QRVersionCapacityTable = require('./qrcapacitytable.js').QRCapacityTable;\nvar QRCode = QRCodeLib.QRCode;\n\nexports.QRCodeDraw = QRCodeDraw;\nexports.QRVersionCapacityTable = QRVersionCapacityTable;\nexports.QRErrorCorrectLevel = QRCodeLib.QRErrorCorrectLevel;\nexports.QRCode = QRCodeLib.QRCode;\n\nfunction QRCodeDraw(){}\n\nQRCodeDraw.prototype = {\n  scale:4,//4 px module size\n  defaultMargin:20,\n  marginScaleFactor:5,\n  Array:(typeof Uint32Array == 'undefined'?Uint32Array:Array),\n  // you may configure the error behavior for input string too long\n  errorBehavior:{\n    length:'trim'\n  },\n  color:{\n    dark:'black',\n    light:'white'\n  },\n  defaultErrorCorrectLevel:QRCodeLib.QRErrorCorrectLevel.H,\n  QRErrorCorrectLevel:QRCodeLib.QRErrorCorrectLevel,\n  draw:function(canvas,text,options,cb){\n    var cb,\n        options = {},\n        level,\n        error;\n\n    \n    var args = Array.prototype.slice.call(arguments);\n    cb = args.pop(); \n    canvas = args.shift();\n    options = args.shift()||{};\n\n    \n    if(typeof cb != 'function') {\n      //enforce callback api just in case the processing can be made async in the future\n      // or support proc open to libqrencode\n      throw new Error('callback required');\n    }\n    \n    if(typeof options !== \"object\"){\n      options.errorCorrectLevel = options;\n    }\n    \n\n    this.QRVersion(text,options.errorCorrectLevel||this.QRErrorCorrectLevel.H,options.version,function(e,t,l,ec){\n      text = t,level = l,error = e,errorCorrectLevel = ec;\n    });\n\n    this.scale = options.scale||this.scale;\n    this.margin = options.margin||this.scale*2;\n    \n    if(!level) {\n      //if we are unable to find an appropriate qr level error out\n      cb(error,canvas);\n      return;\n    }\n\n    //create qrcode!\n    try{\n      \n      var qr = new QRCodeLib.QRCode(level, errorCorrectLevel)\n      , scale = this.scale||4\n      , ctx = canvas.getContext('2d')\n      , width = 0;\n\n      qr.addData(text);\n      qr.make();\n\n      var margin = this.marginWidth();      \n      var currenty = margin;\n      \n      width = this.dataWidth(qr)+ margin*2;\n      \n      this.resetCanvas(canvas,ctx,width);\n\n      for (var r = 0,rl=qr.getModuleCount(); r < rl; r++) {\n        var currentx = margin;\n        for (var c = 0,cl=qr.getModuleCount(); c < cl; c++) {\n          if (qr.isDark(r, c) ) {\n            ctx.fillStyle = this.color.dark;\n            ctx.fillRect (currentx, currenty, scale, scale);\n          } else if(this.color.light){\n            //if falsy configured color\n            ctx.fillStyle = this.color.light;\n            ctx.fillRect (currentx, currenty, scale, scale);\n          }\n          currentx += scale;\n        }\n        currenty += scale;\n      }\n    } catch (e) {\n      error = e;\n    }\n    \n    cb(error,canvas,width);    \n  },\n  drawBitArray:function(text/*,errorCorrectLevel,options,cb*/) {\n\n    var args = Array.prototype.slice.call(arguments),\n      cb = args.pop(),\n      text = args.shift(),\n      errorCorrectLevel = args.shift(),\n      options = args.shift() || {};\n\n    //argument processing\n    if(typeof cb != 'function') {\n      //enforce callback api just in case the processing can be made async in the future\n      // or support proc open to libqrencode\n      throw new Error('callback required as last argument');\n    }\n    \n    cb = arguments[arguments.length-1]; \n    \n    if(arguments.length > 2){\n      errorCorrectLevel = arguments[2];\n    }\n\n\n    //this interface kinda sucks - there is very small likelyhood of this ever being async\n    this.QRVersion(text,errorCorrectLevel,(options||{}).version,function(e,t,l,ec){\n      text = t,level = l,error = e,errorCorrectLevel = ec;\n    });\n\n   //console.log(text,level,error,errorCorrectLevel); \n\n   if(!level) {\n      //if we are unable to find an appropriate qr level error out\n      cb(error,[],0);\n      return;\n    }\n\n    //create qrcode!\n    try{\n\n      var qr = new QRCodeLib.QRCode(level, errorCorrectLevel)\n      , scale = this.scale||4\n      , width = 0,bits,bitc=0,currenty=0;\n      \n      qr.addData(text);\n      qr.make();\n      \n      width = this.dataWidth(qr,1);\n      bits = new this.Array(width*width);\n\n      \n      for (var r = 0,rl=qr.getModuleCount(); r < rl; r++) {\n        for (var c = 0,cl=qr.getModuleCount(); c < cl; c++) {\n          if (qr.isDark(r, c) ) {\n            bits[bitc] = 1;\n          } else {\n            bits[bitc] = 0;\n          }\n          bitc++;\n        }\n      }\n    } catch (e) {\n      error = e;\n      console.log(e.stack);\n    }\n    \n    cb(error,bits,width);\n  },\n  QRVersion:function(text,errorCorrectLevel,version,cb){\n    var c = text.length, \n        error,\n        errorCorrectLevel = this.QRErrorCorrectLevel[errorCorrectLevel]||this.defaultErrorCorrectLevel,\n        errorCorrectIndex = [1,0,3,2],//fix odd mapping to order in table\n        keys = ['L','M','Q','H'],\n        capacity = 0,\n        versionSpecified = false;\n\n        \n    if(typeof version !== \"undefined\" && version !== null) {\n      versionSpecified = true;\n    }\n    //TODO ADD THROW FOR INVALID errorCorrectLevel...?\n    \n    if(versionSpecified){\n      console.log('SPECIFIED VERSION! ',version);\n      //i have specified a version. this will give me a fixed size qr code. version must be valid. 1-40\n      capacity = QRVersionCapacityTable[version][errorCorrectIndex[errorCorrectLevel]];\n      \n    } else {\n      //figure out what version can hold the amount of text\n      for(var i=0,j=QRVersionCapacityTable.length;i<j;i++) {\n        capacity = QRVersionCapacityTable[i][errorCorrectIndex[errorCorrectLevel]];\n        if(c < QRVersionCapacityTable[i][errorCorrectIndex[errorCorrectLevel]]){\n          version = i+1;\n          break;\n        }\n      }\n      //if not version set to max\n      if(!version) {\n        version = QRVersionCapacityTable.length-1;\n      }\n    }\n    \n    if(capacity < c){\n      if(this.errorBehavior.length == 'trim'){\n        text = text.substr(0,capacity);\n        level = QRVersionCapacityTable.length; \n      } else {\n        error = new Error('input string too long for error correction '\n          +keys[errorCorrectIndex[errorCorrectLevel]]\n          +' max length '\n          + capacity\n          +' for qrcode version '+version\n        );\n      }\n    }\n  \n    if(cb) {\n      cb(error,text,version,errorCorrectLevel);\n    }\n    return version;\n  },\n  marginWidth:function(){\n    var margin = this.defaultMargin;\n    this.scale = this.scale||4;\n    //elegant white space next to code is required by spec\n    if (this.scale * this.marginScaleFactor > margin) {\n      margin = this.scale * this.marginScaleFactor;\n    }\n    return margin;\n  },\n  dataWidth:function(qr,scale){\n    return qr.getModuleCount()*(scale||this.scale||4);\n  },\n  resetCanvas:function(canvas,ctx,width){\n    ctx.clearRect(0,0,canvas.width,canvas.height);\n    if(!canvas.style) canvas.style = {};\n    canvas.style.height = canvas.height = width;//square!\n    canvas.style.width = canvas.width = width;\n    \n    if(this.color.light){\n      ctx.fillStyle = this.color.light; \n      ctx.fillRect(0,0,canvas.width,canvas.height);\n    } else {\n      //support transparent backgrounds?\n      //not exactly to spec but i really would like someone to be able to add a background with heavily reduced luminosity for simple branding\n      //i could just ditch this because you could also just set #******00 as the color =P\n      ctx.clearRect(0,0,canvas.width,canvas.height);\n    }\n  }\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":7995}]],"length":7995}
